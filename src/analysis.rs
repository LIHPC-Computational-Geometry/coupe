//! This modules contains functions to help evaluate the quality
//! of the results generated by the partitioning algorithms

use itertools::Itertools;
use snowflake::ProcessUniqueId;

use geometry::{Mbr2D, Point2D};

/// Computes the aspect_ratios of several partitions.
///
/// Returns an array of `(ProcessUniqueId, f64)` which associates
/// each partition id to an aspect ratio.
///
/// The size of the returned vector is equal to the number of different
/// ids contained in `partition_id`.
pub fn aspect_ratios(
    partition_ids: &[ProcessUniqueId],
    points: &[Point2D],
) -> Vec<(ProcessUniqueId, f64)> {
    // Extract each unique partition id from the inpu vector
    let possible_ids = partition_ids.iter().unique();

    // Construct a mapping from each unique partition id
    // to an array containing the points that are contained in that partition
    let id_map: Vec<(ProcessUniqueId, Vec<Point2D>)> = possible_ids
        .map(|id| {
            (
                *id,
                partition_ids
                    .iter()
                    .zip(points)
                    .filter(|(id_local, _)| *id == **id_local)
                    .map(|(_, p)| *p)
                    .collect(),
            )
        }).collect();

    // for each unique id, turn the constructed
    // array of points into its aspect ratio
    id_map
        .into_iter()
        .map(|(id, points)| (id, Mbr2D::from_points(points.iter()).aspect_ratio()))
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_aspect_ratios() {
        let id1 = ProcessUniqueId::new();
        let id2 = ProcessUniqueId::new();

        let ids = vec![id1, id1, id1, id1, id2, id2, id2, id2];
        let points = vec![
            // first rectangle
            Point2D::new(0., 0.),
            Point2D::new(0., 8.),
            Point2D::new(2., 0.),
            Point2D::new(2., 8.),
            // second rectangle
            Point2D::new(-1., 1.),
            Point2D::new(1., -1.),
            Point2D::new(1., 1.),
            Point2D::new(-1., -1.),
        ];

        let ratios = aspect_ratios(&ids, &points);

        for (id, ratio) in ratios {
            match id {
                id if id == id1 => assert_ulps_eq!(ratio, 4.),
                id if id == id2 => assert_ulps_eq!(ratio, 1.),
                _ => unreachable!(),
            }
        }
    }
}
