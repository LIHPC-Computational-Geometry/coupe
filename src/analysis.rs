//! This modules contains functions to help evaluate the quality
//! of the results generated by the partitioning algorithms

use itertools::Itertools;
use snowflake::ProcessUniqueId;

use std::collections::HashMap;

use geometry::{Mbr2D, Point2D};

pub fn aspect_ratios(
    partition_ids: &[ProcessUniqueId],
    points: &[Point2D],
) -> Vec<(ProcessUniqueId, f64)> {
    let possible_ids = partition_ids.iter().unique();
    let id_map: HashMap<ProcessUniqueId, Vec<Point2D>> = possible_ids
        .map(|id| {
            (
                *id,
                partition_ids
                    .iter()
                    .zip(points)
                    .filter(|(id_local, _)| *id == **id_local)
                    .map(|(_, p)| *p)
                    .collect(),
            )
        }).collect();

    id_map
        .into_iter()
        .map(|(id, points)| (id, Mbr2D::from_points(points.iter()).aspect_ratio()))
        .collect()
}
